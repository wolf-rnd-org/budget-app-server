import { readJson } from "../utils/fileDB.js"; // או fileDB.js בהתאם לשם
import { base } from "../utils/airtableConfig.js";

import { z } from "zod";

const ExpenseSchema = z.object({
  id: z.string(),
  budget: z.number(),
  project: z.string(),
  date: z.string(),
  categories: z.union([z.array(z.string()), z.string()]),
  amount: z.number(),
  invoice_description: z.string(),
  supplier_name: z.string().optional().default(""),
  invoice_file: z.string().optional().default(""),
  business_number: z.string().optional().default(""),
  invoice_type: z.string().optional().default(""),
  bank_details_file: z.string().optional().default(""),
  supplier_email: z.string().optional().default(""),
  status: z.string().optional().default(""),
  user_id: z.union([z.number(), z.string()]),
});
export type Expense = z.infer<typeof ExpenseSchema>;

async function loadAll(): Promise<Expense[]> {
  const raw = await readJson<unknown>("expenses.json"); // ⚠️ כאן ודאי שזה expenses.json
  if (!Array.isArray(raw)) throw new Error("expenses.json must be an array");
  return raw.map((x) => ExpenseSchema.parse(x));
}

export async function list(params: {
  userId: number;
  programId?: string;
  page?: number;
  pageSize?: number;
}) {
  const { userId, programId, page = 1, pageSize = 20 } = params;
  const all = await loadAll();

  // סינון לפי userId (מוק: רוב הרשומות 101, זה בסדר)
  const byUser = all.filter(e => String(e.user_id) === String(userId));

  // סינון לפי programId (במוק לפי substring בשם ה־project)
  const filtered = programId
    ? byUser.filter(e =>
        typeof e.project === "string" &&
        (e.project.includes(programId) || e.project.includes("24640") || e.project.includes("24864"))
      )
    : byUser;

  // אם חשוב לך לראות את "כל הספקים" במוק – בטלי פאג’ינציה:
  // const data = filtered; const hasMore = false;

  // אחרת: פאג’ינציה רגילה
  const start = (page - 1) * pageSize;
  const data = filtered.slice(start, start + pageSize);
  const totalCount = filtered.length;
  const hasMore = start + pageSize < totalCount;

  return { data, hasMore, totalCount };
}

                        
type AirtableRow = Record<string, any>;


  
export async function getExpenses (
  programId: string,
  page: number = 1,
  pageSize: number = 50
): Promise<{ data: AirtableRow[]; hasMore: boolean; totalCount: number }> {
  const esc = programId.replace(/"/g, '\\"');

  // מאתרים את רשומת ה-Program לפי program_id (טקסט בטבלת "programs")
  const [program] = await base("programs")
    .select({ filterByFormula: `{program_id} = "${esc}"`, maxRecords: 1, pageSize: 1 })
    .all();

  // אם לא נמצאה תכנית – מחזירים מבנה ריק
  if (!program) return { data: [], hasMore: false, totalCount: 0 };

  // פילטר שמכסה גם Linked Record וגם טקסט רגיל ב-Expenses
  const filter = `OR(FIND("${program.id}", ARRAYJOIN({program_id})), {program_id} = "${esc}")`;

  const fieldsToReturn = [
    "expense_id",
    "budget_id",
    "program_id",
    "date",
    "categories",
    "amount",
    "invoice_description",
    "supplier_name",
    "invoice_file",
    "business_number",
    "invoice_type",
    "bank_details_file",
    "supplier_email",
    "status",
    "user_id",
  ];

  const start = Math.max(0, (Math.max(1, page) - 1) * Math.max(1, pageSize));
  const endExclusive = start + Math.max(1, pageSize);

  const data: AirtableRow[] = [];
  let totalCount = 0;

  // נריץ את כל העמודים כדי לקבל totalCount מדויק, ונאסוף רק את הטווח של הדף המבוקש
  await base("expenses")
    .select({
      filterByFormula: filter,
     // fields: fieldsToReturn,
      pageSize: 100, // גודל עמוד פנימי מול Airtable; לא קשור ל-pageSize של הלקוח
    })
    .eachPage((records, fetchNextPage) => {
      for (const rec of records) {
        const globalIndex = totalCount; // לפני ההגדלה
        if (globalIndex >= start && globalIndex < endExclusive) {
          data.push({ id: rec.id, ...rec.fields });
        }
        totalCount++;
      }
      fetchNextPage();
    });

  const hasMore = totalCount > endExclusive;

  return { data, hasMore, totalCount };
}  
